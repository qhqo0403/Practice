// Big O Notation (빅오 표기법) : 여러 코드들의 성능을 평가하는 방법


// 숫자를 입력받고 1 에서부터 입력받은 숫자사이의 모든 숫자를 더하는 함수
const addUpTo = n => {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  };
  return total;
};

// 다른 방식
const addUpTo2 = n => {
  return n * (n - 1) / 2;
};

/*

************시간 복잡도 측면****************
// 입력 크기와 실행 시간의 관계

performance.now() 메서드를 이용해서 두 함수의 실행 시간을 비교해서 더 빠른 함수를 찾아 낼 수 있음
performance.now -> 브라우저 안에서 문서가 열리는데 걸리는 시간
const t1 = performance.now() // 함수가 실행되기 전 문서가 열리는 데에 소요된 시간을 변수에 담고
addUpTo(6); // 함수를 실행
const t2 = performance.now(); // 새로운 변수에 문서가 열려있는 시간을 할당
console.log((t1 - t2) * 1000); // 함수를 실행하는데에 걸리는 시간을 구할 수 있음, 초단위로 변환하기 위해서 *1000
// 실행 결과를 비교해보면 addUpTo2 가 속도가 더 빠름


performance.now 를 이용해서 함수의 실행시간을 비교하는 것은 절대적인 수치가 아님
-> 기기마다 다른 방식으로 시간을 기록할 수도 있고 사양 등에 따라서 달라질 수 있기 때문
-> 너무 빠른 실행 시간은 측정할 수가 없어서 비교할 수가 없다
-> 함수마다 이런식으로 평가 해주는 것이 번거로움(심지어 비교해야할 함수가 많다면?)
-> 이런 상황을 위해서 빅오표기법이 존재하는 것!

// 시간 외의 연산의 갯수를 비교하는 방법도 있음


빅오 표기법에 따라서 
- 입력의 크기만큼 실행시간이 1:1로 비례하여 늘어날 경우 -> O(n)
  => 2n, 3n 등의 형태는 소용이 없음! 중첩된 경우가 아니고 n이(연산) 여러개 있어도 O(n)
  => O(2n), O(n + 10), O(n + 10000) 모두 상관없이 O(n)으로 표기

- 입력의 크기와 관계없이 같거나 비슷한 시간이 소요될 경우 -> O(1)
  => O(20), O(500) 상관없이 n(1) 상수는 그냥 상수!

- 입력의 크기에 제곱만큼 비례한 시간이 소요될 경우 -> O(n²)
  ex) 루프 안에 중첩 루프가 있는 경우 
  => O(2n² + n + 10) 의 경우 추세를 파악해보면 2n²에 비해 다른 값이 작기 때문에 O(n²)이 됨
  => O(n³ + n²) 은 위의 설명과 같은 방식으로 O(n³)이 됨!


- 연산자에 소요되는 시간은 같음 (+, -, /, *, ...)
- 변수에 값이 할당되는 시간은 같음
- 배열에서 특정 인덱스의 값, 그러니까 value에 접근하는 시간은 같음! 
*/

/*
************공간 복잡도 측면****************
// 입력의 크기와 관계없이 알고리즘 자체가 차지하는 공간과의 관계

- boolean, number, undefined, null 이 차지하는 공간은 항상 같음
- 문자열의 경우에는 O(n)을 따름 -> 문자열의 길이만큼 차지하는 공간이 달라지기 때문
- 참조값인 배열과 객체도 O(n)을 따름
*/

const sum = (arr) => {
  let total;
  for (let i = 0; i < arr.length; i ++) {
    total += arr[i];
  }
  return total;
};
// 배열을 인자로 받아서 배열 내의 모든 값을 더해서 total를 반환 해주는 함수
// 함수가 실행되는데 걸리는 시간과 관계 없이 i가 할당되고 total 변수가 할당 되었기 때문에 O(1) 로 표시할 수 있음 -> 입력되는 크기와 상관없이 변수 하나로 출력되기 때문에 차지하는 공간은 같음

const double = (arr) => {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    newArr.push(arr[i] * 2);
  }
  return newArr;
};
// 배열을 인자로 받아서 모든 값을 두 배로 변환하여 새로운 배열로 반환해주는 함수
// 입력받은 크기만큼 출력되는 값도 커지기 때문에 O(n) 이 됨!

//O(log n), O(nlog n)도 있음! (계산하는 방법은 쓰게된다면 강의 다시 참고하기!)

/* 
=> 알고리즘의 성능을 분석하기 위해서는 빅오 표기법을 사용함.
=> 실행시간이 어떻게 변화하는지(시간복잡도), 어느정도의 용량을 차지하는지(공간복잡도)에 따라 성능을 평가
=> 컴퓨터의 성능과 관계없이 연산의 갯수와 시간에 포커스
 */