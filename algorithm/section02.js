// 배열과 객체의 성능 평가

/* 
//객체 (데이터가 정렬되어 있지 않음)
객체에서 값을 저장, 삭제하거나 값에 접근할 때 O(1) -> 빠름!
객체 내에서 값을 검색할 때에는 O(n)

값을 검색하는 메서드의 예로는 keys, values, entries
위의 메서드들은 객체를 넘겨주면 그 크기만큼의 연산을 수행하기 때문에 O(n)
예외적으로 Object.haOwnsProperty 는 O(1)임! -> 특정 값을 넘겨주기 때문

=> 객체는 정렬되어 있지 않기 때문에 대부분의 모든 연산이 빠르게 이루어짐. 연산, 입력, 접근, 업데이트, 제거는 상수시간
 */

/* 
//배열 (데이터가 정렬되어 있음)
배열의 값에 접근할 때에는 상수시간 O(1) -> 찾고자하는 값의 인덱스가 있다면 그 인덱스를 통해서 값에 접근하기 때문에 상수시간
값을 검색할 때는 객체와 같이 O(n)
값을 추가하거나 삭제하는 것은 어떤 메서드를 쓰느냐에 따라서 달라질 수 있음

push의 경우 배열의 맨 끝에 추가 되는 것이기 때문에 객체에서 값을 추가하는 것과 같음 -> O(1)
unshift의 경우 배열의 맨 앞자리에 값이 추가되는 것으로 기존 값들의 인덱스롤 다 다시 배정해야하기 때문에 배열의 크기가 커질수록 오래걸림! -> O(n)
데이터를 제거하는 pop, shift도 같은 방식으로 평가할 수 있음

그 외 대부분의 배열 메서드들은 O(n)인 경우가 많음. (sort는 O(n logn))
 */